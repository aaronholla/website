---
section: 2-Advanced
---

# Server Side Rendering

So you keep hearing "SSR is zero config" -
but what does that actually mean?
Put short -
consumers of your components don't have to do anything to make it work.
Just import and go.

This is accomplished by inlining `style` elements in the server rendered markup,
like so:

<!-- prettier-ignore -->
```html
<style>._k48pni7l{font-weight:600}</style>
<div class="_k48pni7l">
  <style>._syaz18rw{color:#ff5630}</style>
  <div class="_syaz18rw">hello world</div>
</div>
```

And then on the client when the JavaScript initializes they get moved to the head of the document,
so we end up with this on the client:

```html
<div class="_k48pni7l">
  <div class="_syaz18rw">hello world</div>
</div>
```

The magic sauce though -
is that if any of the same component is rendered multiple times only the _first_ element will have a matching `style` element.

<!-- prettier-ignore -->
```html
<style>._k48pni7l{font-weight:600}</style>
<div class="_k48pni7l">
  <style>._syaz18rw{color:#ff5630}</style>
  <div class="_syaz18rw">hello world</div>
  <div class="_syaz18rw">hello world</div>
  <div class="_syaz18rw">hello world</div>
  <div class="_syaz18rw">hello world</div>
</div>
```

This strategy has a few benefits -
the biggest being when rendering with the [streaming API](https://reactjs.org/docs/react-dom-server.html#rendertonodestream) your component styles are streamed together with your component markup,
resulting in content being rendered to users faster.

> **Warning** - This can interfere with nth child and similar selectors as it is inserts style tags directly into your markup.
> We have an [RFC where we are thinking about what to do with this](https://github.com/atlassian-labs/compiled/issues/31) - please join the conversation!

## Selector workarounds

There are a few workarounds for the nth child type selector problems.

> **Note** - Try to only use these workarounds if you can't think of an alternate implementation,
> such as applying styles directly to the element you're interested in.

### First child

Luckily this one is easy.
Let's say we're targetting the `:first-child` child.

```jsx
<div css={`
  > :first-child {
    color: red;
  }
`}>
  <div /> <-- text will be red, after JavaScript executes
  <div />
</div>
```

But the text isn't red before the JavaScript has executed!
What can we do?

Use a different selector.

```jsx
<div css={`
  > [data-first-child] {
    color: red;
  }
`}>
  <div data-first-child /> <-- text will be red, always
  <div />
</div>
```

Right now this is really the only sure fire way of getting what we want.

### Nth-child

This also applies to `:nth-child` as well,
where `style` elements can appear and ruin our day before JavaScript has executed.

```jsx
<div css={`
  > :nth-child(even) {
    color: red;
  }

  > :nth-child(odd) {
    color: blue;
  }
`}>
  <div /> <-- text will be red, after JavaScript executes
  <div /> <-- text will be blue, after JavaScript executes
</div>
```

```jsx
<div css={`
  > [data-even] {
    color: red;
  }

  > [data-odd] {
    color: blue;
  }
`}>
  <div data-even /> <-- text will be red, always
  <div data-odd /> <-- text will be blue, always
</div>
```
